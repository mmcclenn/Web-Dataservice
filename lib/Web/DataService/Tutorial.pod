
=head1 NAME

Web::DataService::Tutorial - how to build an application using Web::DataService

=head1 SYNOPSIS

This file explains the process of creating a Web::DataService application,
using the example code provided as part of this distribution.  The sections
below will include instructions for setting up an example Web::DataService
application, along with a description of what each part does.  You can the use
this as a basis for your own data service application.

=head1 GETTING STARTED

In order to build an application using Web::DataService, you must start with a
I<foundation framework>.  The only one currently available is L<Dancer>,
though we hope to soon release plugins that will enable Web::DataService
applications to be written on top of other frameworks such as C<Catalyst>,
C<Mojolicious>, C<Dancer2>, etc.

=over 

=item 1.

The first step, therefore, is to make sure that L<Dancer> is installed on your
system.  You will also want to install L<Template>, which is used for
displaying documentation pages.

=item 2.

Next, create a new Dancer project using the script C<dancer> which is included
with that module:

    dancer -a dstest

This will create a new directory called 'dstest' and install into it
all of the necessary files for a Dancer application.

=item 3.

Next, use the script C<dsinstallfiles>, which is included with the current
module, to add the necessary files for the example data service.  You must
first make the project directory the current working directory:

    cd dstest
    dsinstallfiles

When the script asks if you want to overwrite 'config.yml', respond with 'a'
to indicate that any files already existing in the directory should be
overwritten.

This invocation will create the data service application as F<lib/Example.pl>.
The stub program used to invoke the data service is F<bin/dataservice.pl>.

=item 4.

Run the application, and verify that it executes without error.  It will
listen for requests on port 3000, unless you override this using the "Port"
directive in the configuration file.

    bin/dataservice.pl

Once it is running, you can open a web browser and view the documentation for
this data service under the following URL:

    http://localhost:3000/data1.0/

You can test the data service by sending some requests such as:

    http://localhost:3000/data1.0/single.json?state=NY
    http://localhost:3000/data1.0/list.txt?region=NE,MW&show=hist,total

=item 5.

Try editing Example.pm and/or PopulationData.pm, and then re-running the
application to see how the behavior changes.  Here are some things to try:

=over

=item *

Change the title and/or docstring for one or more of the nodes defined in
F<Example.pm>.

=item *

Disable the feature 'format_suffix' and add the special parameter 'format' in
the call that instantiates the data service in F<Example.pm>:

    features => 'standard, no_format_suffix',
    special_params => 'standard, format',

=item *

Disable the feature 'documentation' in F<Example.pm>:

    features => 'standard, no_documentation',

=item *

Change the names and/or docstrings of one or more of the output fields specified in
F<PopulationData.pm>.

=item *

Change the names and/or docstrings of one or more of the parameters specified
in F<PopulationData.pm>.

=item *

Add a new value for the parameter "order", that will sort the states by their
population in 1900 instead of by their population in 2000.

=back

=item 6.

You can now use this example project as a base for creating your own data
service.  The various pieces of the code are described below, along with the
function of each and some ideas for how you might want to modify them.

=back

=head1 OVERVIEW

Under the Web::DataService framework, a data service application consists of
the components listed below.  In order to create your own data service using this
framework, you will have to write each of the following:

=over

=item Main application

The main application, written using a foundation framework such as L<Dancer>, is responsible for initializing
all of the necessary elements to define a data service and for providing the basic response loop.  It must
start by creating a new instance of L<Web::DataService> and then define a variety of data service elements
(see L<Web::DataService::Configuration>) so as to configure the Web::DataService code to handle the various
kinds of data service operations that make up your application.

The main application must respond appropriately to each incoming request, which in the case of Dancer means
defining one or more L<route handlers|Dancer::Introduction/USAGE> that specify the response to each possible
URL path.  In the simplest case, as shown in the L<example application|/lib/Example.pm> below, the route code
reduces to the following:

    return $ds->handle_request(request);

Finally, the main application is responsible for error handling.  The example
application hands off all errors to the Web::DataService code, rather than
using the native Dancer error response.

=item Configuration file

The foundation framework includes a configuration file (L</config.yml> in the
case of Dancer) in which you can specify many of the attributes of your data
service.  Specifying them here rather than putting them in the code will allow
others to easily find and change them as necessary during the process of
developing and maintaining your data service.

=item Data service roles and methods

The "meat" of your data service consists of subroutines that talk to the
backend data store to fetch and/or store the necessary data.  You will need to
write one of these for each different operation provided by your data service.
These are called I<operation methods> and, as the name suggests, are called as
methods of a L<Web::DataService::Request> object.

These operation methods must be organized into one or more modules that can
function as L<Moo> L<roles|Moo::Role>.  These modules will then be
automatically composed into appropriate subclasses of
Web::DataService::Request.  Your role files may include any other code that
you wish, and your operation methods may also call any of the methods provided
by L<Web::DataService::Request>.  For more information, see L</lib/Example.pm>.

=item Documentation templates

Each feature of your data service should be documented by an appropriate web page.  Fortunately,
Web::DataService provides facilities for auto-generating most of the necessary documentation based on the data
service element definitions.

The documentation files take the form of templates, which can include a variety of predefined elements.  At
the time of template evaluation these are replaced by various sections of auto-generated documentation.  The
only templating system currently supported is L<Template-Toolkit>.  We plan to include others in the
near future.

=back

=head1 FILES

This section will cover the files from the example data service one at a time, hilighting the important
features of each.  You can use these files, and this example application, as a basis for your own projects.
When going through this section, you may wish to open each file in turn so as to have the contents visible
while reading the description.

=head2 config.yml

This is the main configuration file for the data service application.  As you can see from the comments, some
of the settings are used by Dancer and others by Web::DataService.  In general, most of the
L<data service attributes|Web::DataService::Configuration/Data service attributes> can be set in this file,
and many of the L<node attributes|Web::DataService::Configuration/Node attributes> can be given default values
in this file.  The example demonstrates this with settings such as C<data_source> and C<default_limit>.

For a description of the configuration settings read by Dancer, see L<Dancer::Config>.

=head2 bin/dataservice.pl

This is just a stub program; the actual application code is in F<lib/Example.pm>, plus the last line of this
file which starts the Dancer main loop.

This program can run standalone, in which case it listens on port 3000 (by default) and is able to respond to
one request at a time.  In order to deploy it as a full-scale web application, you have a number of different
deployment options (see L<Dancer:Deployment>).

=head2 lib/Example.pm

This file contains the main application code for the example data service.  It starts out by declaring the
main package for this application ("Example") and then loading the necessary modules.  L<Dancer> and
L<Template> are required before L<Web::DataService>, so that the latter can configure itself to make use of
them.  Next, we require the module F<lib/PopulationData.pm>.  This defines the operation methods that will be
used to execute the various data service operations for this application.

In lines 42-50, we specify what to do if this application is executed with the command-line argument 'GET'.
In this case the second argument should be a URL path, and the optional third one (which should be
single-quoted if given) should be a URL-encoded parameter string (without the '?').  The application will
proceed to execute this single request and print the result to standard output.  This functionality is useful
primarily for debugging; you can run this under C<perl -d>, and you can put C<$DB::single = 1;> in your code
wherever you wish to have a predefined breakpoint.  For example:

    perl -d bin/dataservice.pl GET /data1.0/list.json 'region=MW&show=total'

In lines 55-60, we generate a L<new instance|Web::DataService::Configuration/Data service instantiation> of
Web::DataService.  This instance will use the standard set of features and special parameters, and will use
"/data1.0" as its path prefix.

The path prefix attribute is not mandatory, but if specified it will be removed from all incoming requests
before they are matched against the set of service nodes.  Later on, if you wish to make changes to the set of
URL paths and parameters for this data service that would break existing client applications, you will be able
to define a second instance with a different path prefix such as "/data1.1".  This instance can then be
configured according to the new way of doing things, while old clients will continue to make requests using
URLs beginning with "/data1.0".  As long as you leave the configuration of the "data1.0" instance unchanged,
these will still work fine.  Similarly, any data service URLs that have been left on old web pages will
continue to work fine.  Newer clients can use URLs beginning with "/data1.1" and can thus access whatever new
functionality that you have now made available with this new version.  And, of course, this pattern can be
continued for as many versions as may be necessary over the lifetime of the data service.

Lines 67-79 specify the L<response formats|Web::DataService::Configuration/Response format definitions> that
will be available from this data service.  In the case of this example, these are: JSON, comma-delimited text,
and tab-delimited text.

Lines 87-140 define a series of data service nodes.  Each of these nodes
corresponds to one of the following:

=over 4

=item 1.

A data service operation, and its accompanying documentation page

=item 2.

A standalone documentation page

=item 3.

A file or files that are available for retrieval (e.g. the stylesheet for the documentation pages).

=back

As explained in L<Web::DataService::Configuration>, nodes inherit their attributes hierarchically according to
their "path" attributes.  The node with path "/" provides default values for all of the other nodes, and also
gives the attributes for the main documentation page.  Note that all of the operation nodes refer to methods
from the module C<PopulationData>, which is described below.

Lines 152-155 define the route handler for all URL requests beginning with /data1.0.  If you end up creating
additional data service instances to handle different versions of the service (see above), you will need to
add additional routes here.  If you wish to configure your data service to use a different method of
indicating versions, or none at all, you will need to modify the route handler definition accordingly.

Lines 158-161 specify that any request whose URL path does not match any of the handlers listed above will
return a HTTP 404 (Not Found) error response.  Because the route handlers are matched in the order defined,
this should always be the last one.

Lines 168-176 are boilerplate code that causes errors to be handled by
Web::DataService rather than by Dancer.

This file is designed to be included from F<bin/dataservice.pl>.  Once it has been fully processed, the last
line of the latter file initiates the Dancer main loop.  This loop waits for incoming requests, and calls the
matching route handler for each one.

=head2 lib/PopulationData.pm

This file defines the elements that make up the data service operations provided by the example application.
These definitions include rules for validating request parameters, formats for the resulting output, and code
that uses the request parameters to retrieve data from the backend.  The calls to C<define_node> in the main
application combine these various elements into data service operation nodes.  A full-scale data service will
often have more than one file like this, one for each different type of data that it handles.

Line 18 defines the package name, which will be used with the node attribute C<role>.

Lines 20-21 define the modules used by this one.  Line 20 provides access to the predefined validator
functions of L<HTTP::Validate>, in case you wish to use them in rulesets.

Line 23 makes this module into a L<Moo> L<role|MOO::Role>, which allows the methods defined here to be
composed into an automatically generated subclass of L<Web::DataService::Request>.

Lines 41-169 define an initialization method which will be called automatically at application startup time.
It is passed two arguments, the first being the class (package) name and the second being the instance of
Web::DataService that is being initialized.  The purpose of this method is two-fold:

=over

=item 1.

Execute any setup tasks that need to be done in order to access the backend data.

=item 2.

Define all of the elements that will be referenced in data service node definitions.

=back

Lines 50-54 accomplish the first of these tasks.  In this simple example, we just read the data out of a
file and store it in lexically scoped variables that can be accessed by the data service operation methods
defined below.  A more complex application might obtain a database connection using the C<get_connection>
method and then use it to read and cache important data.

Lines 59-88 define a set of L<output blocks|Web::DataService::Configuration/Output block definitions> that
select and describe the various data fields that will be returned by data service operations.  The names of
these blocks will be used with the node attribute C<output>.  Note that the actual response to each request
will be automatically generated by the appropriate serialization module, using the appropriate output block(s)
and the set of data records generated by the appropriate operation method, as selected by the request
attributes and by the data service node that matches the request.

Lines 93-97 specify a L<set|Web::DataService::Configuration/Set definitions> of output blocks that can be
optionally added to any request by the use of the special parameter C<show>.  The name of this output map
(set) will be used with the node attribute C<optional_output>.

Lines 102-124 define two more L<sets|Web::DataService::Configuration/Set definitions>.  The first gives the
acceptable values for the parameter C<region>, and the second for the parameter C<order>.

Lines 128-132 define a validator function which will be used for the parameter C<state>.  This function makes
use of a hash of state names that was generated from the data file at line 54 above.

Lines 136-168 define a series of L<rulesets|Web::DataService::Configuration/Ruleset definitions> for
validating request parameters.  The first of these validates the special parameters made available by
Web::DataService.  Note that in the main application file (see above) the data service is instantiated with
the "standard" set of special parameters.  If you modify the instantiation to add or remove some of these
parameters, the ruleset will automatically reflect this.

The remaining rulesets validate the individual request parameters for each available data service operation.
Their names correspond to the node paths defined in F<lib/Example.pm>.  If you wish to use different ruleset
names, you would override this using the node attribute C<ruleset>.

Lines 221-319 define the operation methods that implement the various data service operations.  These are
invoked in response to data service requests, and are called as methods of a request object that has been
blessed into a subclass of L<Web::DataService::Request>.  As such, they are free to call any of the methods
from this class in order to:

=over

=item *

get attributes of the request such as C<request_url>, C<node_path>, C<result_limit>, etc.

=item *

get a connection to the backend data service using C<get_connection>

=item *

get the parameter values that were provided with this request using C<clean_param>, etc.

=item *

specify the result of the operation using C<single_result>, C<list_result>, etc.

=back 

The first of these operation methods returns information about a single state, and is called by the node
'single' (see F</lib/Example.pm>).  This simple operation proceeds by retrieving the cleaned value of the 'state'
parameter and retrieving the corresponding data record.  It finishes by calling the method C<single_result>,
setting the result of the operation to the single record that was retrieved.

The next operation method returns information about multiple states, and is called by the node 'list'.  This is
a much more complex task, involving a number of different possible parameters.  This method retrieves the
relevant parameter values, selects the matching records, orders them as requested, and adds an additional
"total" record if that was requested.  It ends by calling the C<list_result> method, setting the result of the
operation to this list of records.

The final operation method returns the set of region codes, and is called by the node 'regions'.  This is
included so that a client application can retrieve this information and, for example, use it in generating
a web form to be used in making queries on this data service.

By using the power of Web::DataService, this small amount of code can generate a quite complex data service
application along with all of the necessary documentation.

=head2 doc/doc_defs.tt

This file contains all of the definitions necessary for auto-generating the documentation pages.  You probably
don't want to mess with it, unless you have a good understanding of the L<Template-Toolkit|Template> syntax.

=head2 doc/doc_strings.tt

This file contains the text strings used in the process of auto-generating the documentation pages.  You can
edit this file in whatever way you choose, but be careful with the syntax.  Template-Toolkit does not provide
very good error messages.

=head2 doc/doc_header.tt

This file defines a common header for the data service documentation pages.  You can edit it in whatever way
you choose, or use the node attribute C<doc_header> to select a different file.  You can even select different
files for different pages, or use node attribute inheritance to select different files for hierarchical groups
of pages.

See L<Web::DataService::Documentation> for a list of the predefined template elements that you can use
in this file and the ones described below.

=head2 doc/doc_footer.tt

This file defines a common footer for the data service documentation pages.  You can edit it in whatever way
you choose, or use the node attribute C<doc_footer> to select a different file.

=head2 doc/operation.tt

This file provides a template for documentation pages for the operation nodes.  You can edit it in whatever
way you choose, or use the node attribute C<doc_default_op_template> to select a different file.  You can also
create a specific documentation page for any node by creating a template file having the same path relative to
the C<doc> directory as the node path.

=head2 doc/doc_not_found.tt

This file provides a template for documentation pages for the non-operation nodes.  You can edit it in
whatever way you choose, or use the node attribute C<doc_default_template> to select a different file.  You
can also create a specific documentation page for any node by creating a template file having the same path
relative to the C<doc> directory as the node path.

=head2 doc/index.tt

This file serves as the main documentation page for the data service.  You can edit it in whatever way you
choose.

=head2 doc/special_doc.tt

This file documents the special parameters.  Note that it will automatically display just the parameters that
are selected when the data service is instantiated.

=head2 doc/formats/index.tt

This file provides an overview of the available output formats.

=head2 doc/formats/json_doc.tt

This file documents the JSON output format in detail.  If you are using this example as a basis for your own
project, you will want to edit this file and the one listed next so that the example URLs are ones that
actually work under the new data service definition.

=head2 doc/formats/text_doc.tt

This file documents the plain text output formats.

=head3 public/css/dsdoc.css

This file provides a stylesheet for the documentation pages.  You can edit it in whatever way you choose.

=head3 data/population_data.txt

This file provides the data for this example application.

