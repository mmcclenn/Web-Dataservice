#
# Web::DataService::Execute
# 
# This module provides a role that is used by 'Web::DataService'.  It implements
# routines for executing requests.
# 
# Author: Michael McClennen

use strict;

package Web::DataService::Execute;

use Carp 'croak';
use Try::Tiny;
use Scalar::Util 'reftype';

use Moo::Role;


# new_request ( outer, path )
# 
# Generate a new request object, using the given parameters.  $outer should be
# a reference to an "outer" request object that was generated by the
# underlying framework (i.e. Dancer or Mojolicious) or undef if there is
# none.  $path should be the path which is being requested.

sub new_request {

    my ($ds, $outer, $path) = @_;
    
    # A non-empty path must be specified.
    
    croak "invalid path '$path'" if ref $path;
    $path //= '';
    
    # First, check to see whether this path should be handled by one of the
    # subservices or by the main data service.  At the same time, extract the
    # sub-path (typically by removing the prefix corresponding to the selected
    # sub-service) so that we will be able to properly process the request.
    
    my ($selected_ds, $sub_path) = $ds->select_service($path);
    
    # If this path did not match any of the defined data services, we create a
    # special request object whose only use is to generate a 404 error.
    
    unless ( $selected_ds )
    {
	return Web::DataService::Request->new(ds => $ds, 
					      outer => $outer, 
					      raw_path => $path,
					      is_invalid_path => 1);
    }
    
    # Otherwise create a new request object.
    
    else
    {
	my $request = Web::DataService::Request->new(ds => $selected_ds, 
						     outer => $outer, 
						     raw_path => $sub_path);
	
	return $request;
    }
    
    # Make sure that the outer object is linked back to this request object as
    # well.  Our link to it must be weakened so that garbage collection works
    # properly.
    
    # if ( $outer )
    # {
    # 	weaken $request->{outer};
    # 	$outer->{WDS_request} = $request;
    # }
    
    # Return the new request object.
}


# select_service ( path )
# 
# Returns the data service instance for this path, followed by the processed
# path (i.e. with the prefix removed).

sub select_service {
    
    my ($ds, $path) = @_;
    
    # If there are any subservices, check them first.
    
    foreach my $ss ( @{$ds->{subservice_list}} )
    {
	if ( defined $ss->{path_re} && $path =~ $ss->{path_re} )
	{
	    return ($ss, $1);
	}
    }
    
    # Otherwise, try the main service.
    
    if ( $path =~ $ds->{path_re} )
    {
	return ($ds, $1);
    }
    
    # Otherwise, return the empty list.
    
    return;
}


# execute_request ( request )
# 
# Execute a request.  Depending upon the request path, it may either be
# interpreted as a request for documentation or a request to execute some
# operation and return a result.

sub execute_request {
    
    my ($ds, $request) = @_;
    
    my $path = $request->node_path;
    my $format = $request->output_format;
    
    $DB::single = 1;
    
    # If a 'before_execute_hook' was defined for this request, call it now.
    
    $ds->_call_hooks($path, 'before_execute_hook', $request);
    
    # If the request has been tagged as an invalid path, then return a 404 error
    # right away.
    
    die "404\n" if $request->{is_invalid_path};
    
    # If the request has been tagged as a "documentation path", then show the
    # documentation.
    
    if ( $request->{is_node_path} && $request->{is_doc_path} && $ds->has_feature('documentation') )
    {
	return $ds->generate_doc($request);
    }
    
    # If the 'is_file_path' attribute is set, we should be sending a file.
    # Figure out the path and send it.  But an empty 'rest_path' will fall
    # through to a 404 error.
    
    elsif ( $request->{is_file_path} && $request->rest_path )
    {
	return $ds->send_file($request);
    }
    
    # If the selected node has an operation, execute it and return
    # the result.
    
    elsif ( $request->{is_node_path} && $ds->node_has_operation($path) )
    {
	$ds->configure_request($request);
	return $ds->generate_result($request);
    }
    
    # If the request cannot be satisfied in any of those ways (or is invalid)
    # then return a 404 error.
    
    die "404\n";
}


# send_file ( request )
# 
# Send a file using the attributes specified in the request node.

sub send_file {

    my ($ds, $request) = @_;
    
    my $rest_path = $request->rest_path;
    my $file_dir = $ds->node_attr($request, 'file_dir');
    
    die "404\n" if $request->{is_invalid_path};
    
    # An empty file name will always return a 404 error, since the only other
    # logical response would be a list of the base directory and we don't want
    # to provide that for security reasons.
    
    die "404\n" unless defined $rest_path && $rest_path ne '';
    
    # Concatenate the path components together, using the foundation plugin so
    # that this is done in a file-system-independent manner.
    
    my $file_path = $ds->{foundation_plugin}->file_path($file_dir, $rest_path);
    
    # If this file is not readable, return a 404 error.  This is necessary so
    # that the error handling will by done by Web::DataService rather than by
    # Dancer.  If the file exists but is not readable, return a 500 error.
    # This is not a permission error, it is an internal server error.
    
    unless ( $ds->{foundation_plugin}->file_readable($file_path) )
    {
	die "500" if $ds->{foundation_plugin}->file_exists($file_path);
	die "404\n"; # otherwise
    }
    
    # Otherwise, send the file.
    
    return $ds->{foundation_plugin}->send_file($request->_outer, $file_path);
}


# node_has_operation ( path )
# 
# If this class has both a role and a method defined, then return the method
# name.  Return undefined otherwise.  This method can be used to determine
# whether a particular path is valid for executing a data service operation.

sub node_has_operation {
    
    my ($ds, $path) = @_;
    
    my $role = $ds->node_attr($path, 'role');
    my $method = $ds->node_attr($path, 'method');
    
    return $method if $role && $method;
}


# configure_request ( request )
# 
# Determine the attributes necessary for executing the data service operation
# corresponding to the specified request.

sub configure_request {
    
    my ($ds, $request) = @_;
    
    my $path = $request->node_path;
    
    # $DB::single = 1;
    
    die "404\n" if $request->{is_invalid_path};
    
    $request->{_configured} = 1;
    
    # If we are in 'one request' mode, initialize this request's primary
    # role.  If we are not in this mode, then all of the roles will have
    # been previously initialized.
    
    if ( $Web::DataService::ONE_REQUEST )
    {
	my $role = $ds->node_attr($path, 'role');
	$ds->initialize_role($role);
    }
    
    # If a before_config_hook was specified for this node, call it now.
    
    $ds->_call_hooks($path, 'before_config_hook', $request);
    
    # Get the raw parameters for this request, if they have not already been gotten.
    
    $request->{raw_params} //= $ds->{foundation_plugin}->get_params($request);
    
    # Check to see if there is a ruleset corresponding to this path.  If
    # so, then validate the parameters according to that ruleset.
    
    my $rs_name = $ds->node_attr($path, 'ruleset');
    
    $rs_name //= $ds->determine_ruleset($path);
    
    if ( $rs_name )
    {
	my $context = { ds => $ds, request => $request };
	
	my $result = $ds->{validator}->check_params($rs_name, $context, $request->{raw_params});
	
	if ( $result->errors )
	{
	    return $ds->error_result($request, $result);
	}
	
	elsif ( $result->warnings )
	{
	    $request->add_warning($result->warnings);
	}
	
	$request->{clean_params} = $result->values;
	$request->{valid} = $result;
	
	if ( $ds->debug )
	{
	    print STDERR "Params:\n";
	    foreach my $p ( $result->keys )
	    {
		my $value = $result->value($p);
		$value = join(', ', @$value) if ref $value eq 'ARRAY';
		print STDERR "$p = $value\n";
	    }
	}
    }
    
    # Otherwise, just pass the raw parameters along with no validation or
    # processing.
    
    else
    {
	print STDERR "No ruleset could be determined for path '$path'" if $ds->debug;
	$request->{valid} = undef;
	$request->{clean_params} = $request->{raw_params};
    }
    
    # Now that the parameters have been processed, we can configure all of
    # the settings that might be specified or affected by parameter values:
    
    # If the output format is not already set, then try to determine what
    # it should be.
    
    unless ( $request->output_format )
    {
	# If the special parameter 'format' is enabled, check to see if a
	# value for that parameter was given.
	
	my $format;
	my $format_param = $ds->{special}{format};
	
	if ( $format_param )
	{
	    $format = $request->{clean_params}{$format_param};
	}
	
	# If we still don't have a format, and there is a default format
	# specified for this path, use that.
	
	$format //= $ds->node_attr($path, 'default_format');
	
	# If we have successfully determined a format, then set the result
	# object's output format attribute.
	
	$request->output_format($format) if $format;
    }
    
    # Next, determine the result limit and offset, if any.  If the special
    # parameter 'limit' is active, then see if this request included it.
    # If we couldn't get a parameter value, see if a default limit was
    # specified for this node or for the data service as a whole.
    
    my $limit_value = $request->special_value('limit') //
	$ds->node_attr($path, 'default_limit');
    
    $request->result_limit($limit_value) if defined $limit_value;
    
    # If the special parameter 'offset' is active, then see if this result
    # included it.
    
    my $offset_value = $request->special_value('offset');
    
    $request->result_offset($offset_value) if defined $offset_value;
    
    # Determine whether we should show the optional header information in
    # the result.
    
    my $header_value = $request->special_value('header') //
	$ds->node_attr($path, 'default_header');
    
    $request->display_header($header_value) if defined $header_value;
    
    my $source_value = $request->special_value('showsource') //
	$ds->node_attr($path, 'default_showsource');
    
    $request->display_source($source_value) if defined $source_value;
    
    my $count_value = $request->special_value('count') //
	$ds->node_attr($path, 'default_count');
    
    $request->display_counts($count_value) if defined $count_value;
    
    my $output_linebreak = $request->special_value('linebreak') ||
	$ds->node_attr($path, 'default_linebreak') || 'crlf';
    
    $request->output_linebreak($output_linebreak);
    
    my $save_value = $request->special_value('save') //
	$ds->node_attr($path, 'default_save_output');
    
    $request->save_output($save_value) if defined $save_value;
    
    # Determine which vocabulary to use.  If the special parameter 'vocab' is
    # active, check that first.
    
    my $vocab_value = $request->special_value('vocab');
    
    $request->output_vocab($vocab_value) if defined $vocab_value;
    
    # If an after_config_hook is defined for this path, call it.
    
    $ds->_call_hooks($path, 'after_config_hook', $request);
    
    my $a = 1;	# we can stop here when debugging
}


# generate_result ( request )
# 
# Execute the operation corresponding to the attributes of the node selected
# by the given request, and return the resulting data.  This routine is, in
# many ways, the core of this entire project.

sub generate_result {
    
    my ($ds, $request) = @_;
    
    croak "generate_result: you must first call the method 'configure'\n"
	unless $request->{_configured};
    
    my $path = $request->node_path;
    my $format = $request->output_format;
    
    my $method = $ds->node_attr($path, 'method');
    my $arg = $ds->node_attr($path, 'arg');
    
    # First check to make sure that the specified format is valid for the
    # specified path.
    
    unless ( $ds->valid_format_for($path, $format) )
    {
	die "415";
    }
    
    #	defined $format && ref $ds->{format}{$format} &&
    #	 ! $ds->{format}{$format}{disabled} &&
    #	 $attrs->{allow_format}{$format} )
    
    # Then we need to make sure that an output vocabulary is selected.  If no
    # vocabulary was explicitly specified, then try the default for the
    # selected format.  As a backup, we use the first vocabulary defined for
    # the data service, which will be the default vocabulary if none were
    # explicitly defined.
    
    unless ( my $vocab_value = $request->output_vocab )
    {
	$vocab_value = $ds->{format}{$format}{default_vocab} //
	    $ds->{vocab_list}[0];
	
	$request->output_vocab($vocab_value);
    }
    
    # If the format indicates that the output should be returned as an
    # attachment (which tells the browser to save it to disk), note this fact.
    
    if ( defined $ds->{format}{$format}{disposition} &&
	 $ds->{format}{$format}{disposition} eq 'attachment' )
    {
	$request->save_output(1);
    }
    
    # Now that we know the format, we can set the response headers.
    
    $ds->_set_cors_header($request);
    $ds->_set_content_type($request);
    $ds->_set_content_disposition($request);
    
    # Then set up the output.  This involves constructing a list of
    # specifiers that indicate which fields will be included in the output
    # and how they will be processed.
    
    $ds->_setup_output($request);
    
    # Now determine the class that corresponds to this request's primary role
    # and bless the request into that class.
    
    my $role = $ds->node_attr($request, 'role');
    bless $request, $ds->execution_class($role);
    
    # If an after_setup_hook is defined for this path, call it.
    
    $ds->_call_hooks($path, 'after_setup_hook', $request);
    
    # Prepare to time the query operation.
    
    my (@starttime) = Time::HiRes::gettimeofday();
    
    # Now execute the query operation.  This is the central step of this
    # entire routine; everything before and after is in support of this call.
	
    $request->$method($arg);
    
    # Determine how long the query took.
    
    my (@endtime) = Time::HiRes::gettimeofday();
    $request->{elapsed} = Time::HiRes::tv_interval(\@starttime, \@endtime);
    
    # If an after_operation_hook is defined for this path, call it.
    
    $ds->_call_hooks($path, 'after_operation_hook', $request);
    
    # Then we use the output configuration and the result of the query
    # operation to generate the actual output.  How we do this depends
    # upon how the operation method chooses to return its data.  It must
    # set one of the following fields in the request object, as described:
    # 
    # main_data		A scalar, containing data which is to be 
    #			returned as-is without further processing.
    # 
    # main_record	A hashref, representing a single record to be
    #			returned according to the output format.
    # 
    # main_result	A list of hashrefs, representing multiple
    #			records to be returned according to the output
    # 			format.
    # 
    # main_sth		A DBI statement handle, from which all 
    #			records that can be read should be returned
    #			according to the output format.
    # 
    # It is okay for main_result and main_sth to both be set, in which
    # case the records in the former will be sent first and then the
    # latter will be read.
    
    if ( ref $request->{main_record} )
    {
	return $ds->_generate_single_result($request);
    }
    
    elsif ( ref $request->{main_sth} or ref $request->{main_result} )
    {
	my $threshold = $ds->node_attr($path, 'streaming_threshold')
	    unless $request->{do_not_stream};
	
	return $ds->_generate_compound_result($request, $threshold);
    }
    
    elsif ( defined $request->{main_data} )
    {
	return $request->{main_data};
    }
    
    # If none of these fields are set, then the result set is empty.
    
    else
    {
	return $ds->_generate_empty_result($request);
    }
}


# generate_doc ( request )
# 
# Generate and return a documentation page for this request.  The accepted
# formats, one of which was selected when the request was created, are 'html'
# and 'pod'.
# 
# If a documentation template corresponding to the specified path is found, it
# will be used.  Otherwise, a default template will be used.

sub generate_doc {
    
    my ($ds, $request) = @_;
    
    my $path = $request->node_path;
    my $format = $request->output_format;
    
    $DB::single = 1;
    
    # If this is not a valid request, then return a 404 error.
    
    die "404\n" if $request->{is_invalid_path} || $ds->node_attr($path, 'undocumented');
    
    # If we are in 'one request' mode, initialize this request's primary
    # role.  If we are not in this mode, then all of the roles will have
    # been previously initialized.
    
    if ( $Web::DataService::ONE_REQUEST )
    {
	my $role = $ds->node_attr($path, 'role');
	$ds->initialize_role($role);
    }
    
    # We start by determining the values necessary to fill in the documentation
    # template.  This may include one or more of: a title, parameters,
    # response fields, etc.
    
    my $doc_title = $ds->node_attr($path, 'title') // $path;
    
    my $vars = { ds => $ds,
		 request => $request,
		 doc_title => $doc_title };
    
    # All documentation is public, so set the maximally permissive CORS header.
    
    $ds->_set_cors_header($request, "*");
    
    # Now determine the class that corresponds to this request's primary role
    # and bless the request into that class.
    
    my $role = $ds->node_attr($request, 'role');
    bless $request, $ds->documentation_class($role);
    
    # Now determine the location of the template for generating this
    # documentation page.  If one has not been specified, we try the path
    # appended with "/index.tt", and if that does not exist we try the
    # path appended with "_doc.tt".  Or with whatever suffix has been
    # specified for template files.  If none of these template files are
    # present, we try the documentation error template as a backup.
    
    my $doc_suffix = $ds->{template_suffix} // "";
    
    my $doc_defs = $ds->node_attr($path, 'doc_defs') // $ds->check_doc("doc_defs${doc_suffix}");
    my $doc_header = $ds->node_attr($path, 'doc_header') // $ds->check_doc("doc_header${doc_suffix}");
    my $doc_footer = $ds->node_attr($path, 'doc_footer') // $ds->check_doc("doc_footer${doc_suffix}");
    
    # Now see if we can find a template for this documentation page.  If one
    # was explicitly specified, we try that first.  Otherwise, try the node
    # path suffixed by '_doc' with the template suffix added, and then
    # '/index' with the template suffix.
    
    my $doc_template = $ds->node_attr($path, 'doc_template');
    
    if ( defined $doc_template )
    {
	die "404\n" if $doc_template eq '';
	croak "template $doc_template: not found\n" unless $ds->check_doc($doc_template);
    }
    
    else
    {
	my @try_template;
	
	if ( $path eq '/' )
	{
	    push @try_template, 'index' . $doc_suffix;
	}
	
	else
	{
	    push @try_template, $path . '_doc' . $doc_suffix;
	    push @try_template, $path . '/index' . $doc_suffix;
	    push @try_template, $ds->node_attr($path, 'doc_default_op_template')
		if $ds->node_has_operation($path);
	    push @try_template, $ds->node_attr($path, 'doc_default_template');
	}
	
	push @try_template, "doc_not_found${doc_suffix}";
	
 	foreach my $t ( @try_template )
	{
	    $doc_template = $t, last if $ds->check_doc($t);
	}
    } 
    
    # Now, if we have found a template that works then render it.
    
    if ( $doc_template )
    {
	my $doc_string = $ds->render_doc($doc_template, $doc_defs, $doc_header, $doc_footer, $vars);
	
	# If POD format was requested, return the documentation as is.
	
	if ( defined $format && $format eq 'pod' )
	{
	    $ds->_set_content_type($request, 'text/plain');
	    return $doc_string;
	}
	
	# Otherwise, convert the POD to HTML using the PodParser and return the result.
	
	else
	{
	    my $parser = Web::DataService::PodParser->new();
	    
	    $parser->parse_pod($doc_string);
	    
	    my $url_generator = sub {
		if ($_[0] =~ qr{ ^ (node|path) : (.*) }xs )
		{
		    my $arg = $1 eq 'node' ? 'doc' : 'path';
		    my $path = $2 || '/';
		    return $ds->generate_url({ $arg => $path });
		}
		else
		{
		    return $_[0];
		}
	    };
	    
	    my $doc_html = $parser->generate_html({ css => $ds->{doc_stylesheet}, 
						    tables => 1, base_url => $ds->base_url,
						    url_generator => $url_generator });
	    
	    $ds->_set_content_type($request, 'text/html');
	    return $doc_html;
	}
    }
    
    # If no valid template file was found, we return an error result.
    
    else
    {
	die "404\n";
    }
}


# _call_hooks ( path, hook, request )
# 
# If the specified hook has been defined for the specified path, call each of
# the defined values.  If the value is a code reference, call it with the
# request as the only parameter.  If it is a string, call it as a method of
# the request object.

sub _call_hooks {
    
    my ($ds, $path, $hook, $request, @args) = @_;
    
    # Skip this processing entirely unless we know that the specified hook has
    # been defined for at least one node in this data service.
    
    return unless $ds->{hook_enabled}{$hook};
    
    # Otherwise, look up the value for this hook which should either be an
    # array ref or undefined.
    
    $DB::single = 1;
    
    my $hook_value = $ds->node_attr($path, $hook) || return;
    
    foreach my $code ( @$hook_value )
    {
	if ( ref $code eq 'CODE' )
	{
	    return &$code($request);
	}
	
	elsif ( defined $code )
	{
	    return $request->$code();
	}
    }
}


sub _set_cors_header {
    
    my ($ds, $request, $arg) = @_;
    
    # If this is a public-access data service, we add a universal CORS header.
    # At some point we need to add provision for authenticated access.
    
    if ( $arg eq '*' || $ds->node_attr($request, 'public_access') )
    {
	$ds->{foundation_plugin}->set_cors_header("*");
    }
}


sub _set_content_type {

    my ($ds, $request, $ct) = @_;
    
    # If the content type was not explicitly given, choose it based on the
    # output format.
    
    unless ( $ct )
    {
	my $format = $request->output_format;
	$ct = $ds->{format}{$format}{content_type} || 'text/plain';
    }
    
    $ds->{foundation_plugin}->set_content_type($request, $ct);
}


sub _set_content_disposition {
    
    my ($ds, $request, $filename) = @_;
    
    # Return unless we were given an explicit filename or the 'save_output'
    # attribute of this request is true.
    
    return unless $filename || $request->save_output;
    
    # If we weren't given an explicit filename, check to see if one was set
    # for this node.
    
    $filename //= $ds->node_attr($request, 'save_filename');
    
    # If we still don't have a filename, return without doing anything.
    
    return unless $filename;
    
    # Otherwise, set the appropriate header.  If the filename does not already
    # include a suffix, add the format.
    
    unless ( $filename =~ qr{ [^.] . \w+ $ }xs )
    {
	$filename .= '.' . $request->output_format;
    }
    
    $ds->{foundation_plugin}->set_header($request, 'Content-Disposition' => 
					 qq{attachment; filename="$filename"});
}


# determine_ruleset ( )
# 
# Determine the ruleset that should apply to this request.  If a ruleset name
# was explicitly specified for the request path, then use that if it is
# defined or throw an exception if not.  Otherwise, try the path with slashes
# turned into commas and the optional ruleset_prefix applied.

sub determine_ruleset {
    
    my ($ds, $path) = @_;
    
    my $validator = $ds->{validator};
    my $ruleset = $ds->node_attr($path, 'ruleset');
    
    # If a ruleset name was explicitly given, then use that or throw an
    # exception if not defined.
    
    if ( defined $ruleset && $ruleset ne '' )
    {
	croak "unknown ruleset '$ruleset' for path $path"
	    unless $validator->ruleset_defined($ruleset);
	
	return $ruleset;
    }
    
    # If the ruleset was explicitly specified as '', do not process the
    # parameters for this path.
    
    return if defined $ruleset;
    
    # If the path is either empty or the root node '/', likewise return false.
    
    return unless defined $path && $path ne '' && $path ne '/';
    
    # Otherwise, try the path with / replaced by :.  If that is not defined,
    # then return empty.  The parameters for this path will not be processed.
    
    $path =~ s{/}{:}g;
    
    $path = $ds->{ruleset_prefix} . $path
	if defined $ds->{ruleset_prefix} && $ds->{ruleset_prefix} ne '';
    
    return $path if $validator->ruleset_defined($path);
}


# determine_output_names {
# 
# Determine the output block(s) and/or map(s) that should be used for this
# request.  If any output names were explicitly specified for the request
# path, then use them or throw an error if any are undefined.  Otherwise, try
# the path with slashes turned into colons and either ':default' or
# ':default_map' appended.

sub determine_output_names {

    my ($self) = @_;
    
    my $ds = $self->{ds};
    my $path = $self->{path};
    my @output_list = @{$self->{attrs}{output}} if ref $self->{attrs}{output} eq 'ARRAY';
    
    # If any output names were explicitly given, then check to make sure each
    # one corresponds to a known block or set.  Otherwise, throw an exception.
    
    foreach my $output_name ( @output_list )
    {
	croak "the string '$output_name' does not correspond to a defined output block or map"
	    unless ref $ds->{set}{$output_name} eq 'Web::DataService::Set' ||
		ref $ds->{block}{$output_name} eq 'Web::DataService::Block';
    }
    
    # Return the list.
    
    return @output_list;
}


my %CODE_STRING = ( 400 => "Bad Request", 
		    404 => "Not Found", 
		    415 => "Invalid Media Type",
		    500 => "Server Error" );

# error_result ( request, error )
# 
# Send an error response back to the client.  This routine is designed to be
# as flexible as possible about its arguments.  At minimum, it only needs a
# request object - either the one generated by the foundation framework or
# the one generated by Web::DataService.

sub error_result {

    my ($ds, $request, $error) = @_;
    
    # First figure out which kind of request object we have.
    
    my ($inner, $outer);
    
    if ( defined $request && $request->isa('Web::DataService::Request') )
    {
	$inner = $request;
	$outer = $request->_outer;
    }
    
    else
    {
	$inner = undef;
	$outer = $request;
    }
    
    # Next, try to determine the format of the result
    
    my $format = ''; # ref $request ? $request->output_format : '';
    
    my ($code);
    my (@errors, @warnings);
    
    # If the error is actually a response object from HTTP::Validate, then
    # extract the error and warning messages.  In this case, the error code
    # should be "400 bad request".
    
    if ( ref $error eq 'HTTP::Validate::Result' )
    {
	@errors = $error->errors;
	@warnings = $error->warnings;
	$code = "400";
    }
    
    # If the error message begins with a 3-digit number, then that should be
    # used as the code and the rest of the message as the error text.
    
    elsif ( $error =~ qr{ ^ (\d\d\d) \s+ (.*) }xs )
    {
	$code = $1;
	@errors = $2;
    }
    
    elsif ( $error =~ qr{ ^ (\d\d\d) }xs )
    {
	$code = $1;
	if ( $code == 404 )
	{
	    @errors = "Resource not found";
	}
	elsif ( $code == 400 )
	{
	    @errors = "Parameter error";
	}
	else
	{
	    @errors = "Error";
	}
    }
    
    # Otherwise, this is an internal error and all that we should report to
    # the user (for security reasons) is that an error occurred.  The actual
    # message is written to the server error log.
    
    else
    {
	$code = 500;
	warn $error;
	@errors = "A server error occurred.  Please contact the server administrator.";
    }
    
    # If the format is 'json', render the response as a JSON object.
    
    if ( defined $format && $format eq 'json' )
    {
	$error = '"status_code": ' . $code;
	$error .= ",\n" . json_list_value("errors", @errors);
	$error .= ",\n" . json_list_value("warnings", @warnings) if @warnings;
	
	$ds->{foundation_plugin}->set_content_type($request, 'application/json');
	$ds->{foundation_plugin}->set_cors_header($request, "*");
	$ds->{foundation_plugin}->set_status($request, $code);
	Dancer::response->content("{ $error }");
	#$ds->{foundation_plugin}->set_body("{ $error }");
	return "{ $error }\n";
    }
    
    # Otherwise, generate a generic HTML response (we'll add template
    # capability later...)
    
    else
    {
	my $text = $CODE_STRING{$code};
	my $error = "<ul>\n";
	my $warning = '';
	
	$error .= "<li>$_</li>\n" foreach @errors;
	$error .= "</ul>\n";
	
	if ( @warnings )
	{
	    $warning .= "<h2>Warnings:</h2>\n<ul>\n";
	    $warning .= "<li>$_</li>\n" foreach @warnings;
	    $warning .= "</ul>\n";
	}
	
	my $body = <<END_BODY;
<html><head><title>$code $text</title></head>
<body><h1>$code $text</h1>
$error
$warning
</body></html>
END_BODY
    
	$ds->{foundation_plugin}->set_content_type($request, 'text/html');
	$ds->{foundation_plugin}->set_cors_header($request, "*");
	$ds->{foundation_plugin}->set_status($request, $code);
	Dancer::SharedData->response->content($body);
	#$ds->{foundation_plugin}->set_body($request, $body);
	return $body;
    }
}


1;
