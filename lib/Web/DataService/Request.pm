#
# Web::DataService::Request
# 
# A base class that implements a data service for the PaleoDB.  This can be
# subclassed to produce any necessary data service.  For examples, see
# TaxonQuery.pm and CollectionQuery.pm. 
# 
# Author: Michael McClennen

use strict;

package Web::DataService::Request;

use Carp 'croak';

use Moo;
use namespace::clean;

# The required attribute 'ds' is the data service with which this request is
# associated.

has ds => ( is => 'ro', required => 1 );

# The required attribute 'outer' is the request object generated by the
# foundation framework.

has outer => ( is => 'ro', required => 1, reader => '_outer' );

# The required attribute 'path' selects the data service node which will be
# used to process the request.  It may be generated from the raw URL path
# either using 'match_path' or by the application code.  The attribute
# 'node_path' is generated from this by trimming it in various ways, to get a
# key which can be used to look up one of the defined path nodes.  The
# attributes associated with this node are then used to execute the request.
# Any path components trimmed from 'raw_path' are put into 'rest_path'.

has raw_path => ( is => 'ro', required => 1, trigger => 1 );

has node_path => ( is => 'ro', init_arg => undef );

has rest_path => ( is => 'ro', init_arg => undef );

has is_node_path => ( is => 'rw' );

has is_doc_path => ( is => 'rw' );

has is_invalid_path => ( is => 'ro' );

# The attribute 'format' is necessary only if the path does not contain a
# format suffix.

has output_format => ( is => 'rw' );

has output_vocab => ( is => 'rw' );

has output_linebreak => ( is => 'rw' );

# More attributes

has result_limit => ( is => 'rw' );

has result_offset => ( is => 'rw' );

has display_header => ( is => 'rw' );

has display_source => ( is => 'rw' );

has display_counts => ( is => 'rw' );

has save_output => ( is => 'rw' );

has do_not_stream => ( is => 'rw' );


# BUILD ( )
# 
# Finish generating a new request object.  This involves determining the "node
# path" from the "raw path" that was specified when this object was
# initialized.  Depending upon the features enabled for this data service, the
# path may be processed in different ways.

sub BUILD {
    
    my ($self) = @_;
    
    my $ds = $self->{ds};
    
    # The first thing we need to do is to fetch the request parameters using
    # the foundation plugin.  That way, we will have all of the information we
    # need in order to process the request.
    
    # (Note: at some point in the future we will also need to get the HTTP
    # method and some of the headers).
    
    $self->{raw_params} = $ds->{foundation_plugin}->get_params($self);
    
    # If we haven't been able to set the output format from the raw path (see
    # _trigger_raw_path) then we need to determine it if at all possible by
    # other means.  This is necessary even for invalid paths, because if the output
    # format is JSON then the error response will need to be in that format as
    # well.
    
    unless ( $self->{output_format} )
    {
	# We start by checking for the special parameter.  We use lc because
	# the format parameter is mandated to be case-insensitive in order to
	# be compatible with HTTP::Validate (and because that is a good idea
	# in and of itself).
	
	if ( $ds->special_param('format') )
	{
	    $self->{output_format} = lc($self->special_value('format') // '');
	}
	
	# If this parameter is not enabled for this data service, then see if
	# the root node has a default format set for it.  If not, then just
	# set it to the first output format defined.
	
	else
	{
	    $self->{output_format} = $ds->node_attr('/', 'default_format') // ${$ds->{format_list}}[0] // '';
	}
    }
    
    # Now, if 'is_invalid_path' was set, then set the node_path to root (/)
    # and immediately return.  The only possible outcome in this case is a 404
    # error.
    
    if ( $self->{is_invalid_path} )
    {
	$self->{node_path} = '/';
	$self->{is_node_path} = 0;
	return;
    }
}


# _trigger_raw_path ( path )
# 
# This routine is called whenever the 'raw_path' attribute of this request is
# set.  It determines the closest matching 'node_path' and sets some other
# attributes.

sub _trigger_raw_path {
    
    my ($self) = @_;
    
    my $ds = $self->{ds};
    my $raw_path = $self->{raw_path};
    my $missing_suffix;
    
    # The node path starts with the raw path.  Then we trim it in various
    # ways.
    
    my $node_path = $raw_path;
    
    # If the feature 'format_suffix' is enabled and the specified path has a
    # suffix, split it off.
    
    if ( $ds->has_feature('format_suffix') )
    {
	if ( $node_path =~ qr{ ^ (.+) [.] (.+) }xs )
	{
	    $node_path = $1;
	    $self->{output_format} = $2;
	}
	
	else
	{
	    $missing_suffix = 1;
	}
    }
    
    # If the feature 'doc_paths' is enabled and the specified path ends in
    # '_doc', remove that string and set the 'doc_path' attribute for this request.
    # Under this feature, the path "abc/def_doc" indicates a request for
    # doumentation about the path "abc/def".
    
    if ( $ds->has_feature('doc_paths') )
    {
	if ( $node_path eq '' )
	{
	    $self->{is_doc_path} = 1;
	}
	
	elsif ( ref $ds->{doc_path_regex} eq 'Regexp' && $node_path =~ $ds->{doc_path_regex} )
	{
	    $node_path = $1;
	    $self->{is_doc_path} = 1;
	}
	
	elsif ( $ds->{doc_index} && $node_path eq $ds->{doc_index} )
	{
	    $node_path = '';
	    $self->{is_doc_path} = 1;
	}
	
	elsif ( $missing_suffix )
	{
	    $self->{is_doc_path} = 1;
	}
    }
    
    # We then lop off components as necessary until we get to a node that has
    # attributes or until we reach the empty string.  We set the 'is_node_path'
    # flag to 0 (unless it has already been set) to indicate that the request
    # path does not match a defined node.
    
    while ( $node_path ne '' && ! exists $ds->{node_attrs}{$node_path} )
    {
	$self->{is_node_path} //= 0;
	
	if ( $node_path =~ qr{ ^ (.*) / (.*) }xs )
	{
	    $node_path = $1;
	}
	
	else
	{
	    $node_path = '';
	}
    }
    
    # If the selected node is disabled, set the 'is_invalid_path' attribute.
    
    $self->{is_invalid_path} = 1 if $ds->node_attr($node_path, 'disabled');
    
    # If 'is_node_path' has not yet been set, then we assume it should be 1.
    
    $self->{is_node_path} //= 1;
    
    # We save all of the characters removed from the raw path as $rest_path,
    # so that (for example) we can send a requested file.
    
    $self->{rest_path} = substr($raw_path, length($node_path));
    
    # If we got an empty path, turn it into the root node path '/'.
    
    $self->{node_path} = $node_path eq '' ? '/' : $node_path;
    
    # If the node that we got is a 'send_files' node, then mark this request
    # as 'is_file_path'.
    
    if ( $ds->node_attr($self->{node_path}, 'send_files') )
    {
	$self->{is_file_path} = 1;
    }
}


# execute ( )
# 
# Execute this request, and return the result.

sub execute {
    
    return $_[0]->{ds}->execute_request($_[0]);
}


# configure ( )
# 
# Configure this request for execution.

sub configure {

    return $_[0]->{ds}->configure_request($_[0]);
}


# Common methods needed for both execution and documentation

# request_url
# 
# Return the raw (unparsed) request URL

sub request_url {
    
    return $_[0]->{ds}->{foundation_plugin}->request_url($_[0]);
}


# base_url
# 
# Return the base component of the URL for this request, of the form "http://some.host/".

sub base_url {
    
    return $_[0]->{ds}->{foundation_plugin}->get_base_url($_[0]);
}


# root_url ( )
# 
# Return the base url plus the path prefix.

sub root_url {
    
    return $_[0]->{ds}->{foundation_plugin}->get_base_url($_[0]) . $_[0]->{ds}{path_prefix};
}


# path_prefix ( )
# 
# Return the path prefix for this request.

sub path_prefix {
    
    return $_[0]->{ds}{path_prefix};
}


# special_value ( param )
# 
# Return the value of the specified special param, if it is enabled, and if
# it was specified.  Return undefined otherwise.

sub special_value {

    my ($self, $param) = @_;
    
    my $ds = $self->{ds};
    my $param_name = $ds->special_param($param) || return;
    
    # If we have already passed the params through HTTP::Validate, return the
    # cleaned value.
    
    return $self->{valid}->value($param_name) if ref $self->{valid};
    
    # Otherwise, return the raw value if it exists and undefined otherwise.
    
    return $self->{raw_params}{$param_name};
}


=head1 NAME

Web::DataService::Request - interface for handling a single request

=head1 SYNOPSIS

The way that you handle a result using Web::DataService is as follows:

    my $request = $ds->new_request(undef, $path);
    $request->execute;

The C<new_request> method creates a new C<Web::DataService::Request> object,
whose attributes are set according to the given path.

The C<execute> method then processes the request as indicated by these
attributes; if you have specified C<class> and C<method>, then the appropriate
method is called.

=head1 METHODS

=head3 new ( ds, outer, path )

You will probably not call this method directly; instead, call the
C<new_request> method of L<Web::DataService>, which calls it internally after
carrying out other processing such as selecting among sub-services.

If you do call it directly, the parameter C<ds> must be an instance of
C<Web::DataService>. The parameter C<outer> should be a reference to the
request object generated by the underlying Web Application Framework
(i.e. L<Dancer>). The parameter C<path> must be the path corresponding to the
selected operation.

Returns a new instance of C<Web::DataService::Request>, whose attributes are
set from the given path.

=head3 execute ( )

Executes this request, and sends a result message using the foundation
framework.

=head3 clean_param ( param )

Returns the cleaned value of the specified parameter, or undefined if the
parameter was not specified.  If more than one parameter value was given, the
result will be an array ref.

=head3 clean_param_list ( param )

Returns a list of one or more values of the specified parameter, or undefined
if the parameter was not specified.

=head3 result_limit ( )

If the attribute C<limit_param> was specified for the data service, and if it
was specified with this request, then the given value is returned.  If the
parameter was given a value of C<all>, then this method returns undefined.

If the parameter was not specified at all, or if C<limit_param> was never
specified, then the C<default_limit> attribute of the data service is
returned.

=head3 result_offset ( will_handle )

If the attribute C<offset_param> was specified for the data sevice, and if it
was specified with this request with a non-zero value, the given value is
returned.  Otherwise, the method returns 0.

If C<will_handle> is true, then no further processing is done on the result.
If C<will_handle> is false, or if C<result_offset> is never called for this
request, then (if the request includes the parameter whose name is specified
by C<offset_param>, with a numeric value) that number of result records will
be dropped before any output is generated.

If the attribute C<offset_param> is not specified for this data service, or if
that parameter is not included in the request, then no dropping of records
will occur.

=head3 sql_limit_clause ( will_handle )

Returns an SQL C<LIMIT> clause which will reflect the values of C<limit_param>
and C<offset_param>, if one or both were specified for this data service and
if the corresponding parameter(s) were included in this request.  Otherwise,
returns the empty string.

The argument C<will_handle> is treated exactly as with L</result_offset> above.

=head3 sql_count_clause ( )

If the attribute C<count_param> was defined for this data service, and if the
corresponding parameter was included in this request, returns the string
"SQL_CALC_FOUND_ROWS".  Otherwise, returns the empty string.

=head3 sql_count_rows ( )

If the attribute C<count_param> was defined for this data service, and if the
corresponding parameter was included in this request, executes the SQL
statement "SELECT FOUND_ROWS()" and stores the result for later use in
generating a response header.  Otherwise, it does nothing.

=head3 set_result_count ( count )

This method can be used as an alternative to L</sql_count_rows>.  In your own
operation methods, you can check for the size of the result set in whatever
way is appropriate for your backend and call this method with the resulting
number.  If you wish, you can do this only if the parameter C<count_param> was
included with this request.

=head3 add_warning ( message )

Add the specified warning message to this request.  The warnings will be
automatically included in the result, in a manner appropriate for the selected
output format.

=head3 warnings ( )

Return a list of the warning messages (if any) that have been added to this
request. 

=head3 output_format ( )

Return the output format that has been selected for this request.

=head3 get_request_url ( )

Return the raw (unparsed) URL for this request.

=head3 get_base_url ( )

Return the base of the URL for this request.  This will generally be of the
form C<http://domain.name/>.

=head3 get_request_path ( )

Return the remainder of the URL path after the base (but without the format
suffix, if any).

=head3 set_content_type ( content_type )

Set the response content type.  You will probably not need to call this
method, since the content type is generally set automatically based on the
selected output format.

=head1 AUTHOR

mmcclenn "at" cpan.org

=head1 BUGS

Please report any bugs or feature requests to C<bug-web-dataservice at rt.cpan.org>, or through
the web interface at L<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Web-DataService>.  I will be notified, and then you'll
automatically be notified of progress on your bug as I make changes.

=head1 COPYRIGHT & LICENSE

Copyright 2014 Michael McClennen, all rights reserved.

This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

=cut

1;
