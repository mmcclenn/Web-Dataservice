#
# Web::DataService::Request
# 
# A base class that implements a data service for the PaleoDB.  This can be
# subclassed to produce any necessary data service.  For examples, see
# TaxonQuery.pm and CollectionQuery.pm. 
# 
# Author: Michael McClennen

use strict;

package Web::DataService::Request;

use Carp 'croak';

use Moo;
use namespace::clean;

# The required attribute 'ds' is the data service with which this request is
# associated.

has ds => ( is => 'ro', isa => \&is_dataservice_object, required => 1 );

# The required attribute 'outer' is the request object generated by the
# foundation framework.

has outer => ( is => 'ro', required => 1 );

# The attribute 'path' selects the data service node which will be used to
# process the request.  If not given explicitly, it will be retrieved from the
# 'outer' request object.

has path => ( is => 'rw', trigger => \&_match_node );

# The following argument can be specified separately, or you can let it be
# extracted from the value of 'path'.  But note that if 'path' does not
# correspond to a defined node, then 'rest_path' will be modified
# accordingly.

has rest_path => ( is => 'ro' );

# The following attributes will be determined automatically by
# Web::DataService, unless explicitly defined at initialization time or
# explicitly overridden later.

has is_invalid_request => ( is => 'rw' );

has is_doc_request => ( is => 'rw' );

has output_format => ( is => 'rw' );

has output_vocab => ( is => 'rw' );

has output_linebreak => ( is => 'rw' );

has result_limit => ( is => 'rw' );

has result_offset => ( is => 'rw' );

has display_header => ( is => 'rw' ); #, lazy => 1, builder => sub { $_[0]->_init_value('header') } );

has display_source => ( is => 'rw' );

has display_counts => ( is => 'rw' );

has save_output => ( is => 'rw' );

has save_filename => ( is => 'rw' );

has do_not_stream => ( is => 'rw' );

# The following attributes will be determined automatically by
# Web::DataService and should not be overridden.

has node_path => ( is => 'ro', init_arg => '_node_path' );

has is_node_path => ( is => 'ro', init_arg => undef );


# BUILD ( )
# 
# Finish generating a new request object.  This involves determining the "node
# path" from the "raw path" that was specified when this object was
# initialized.  Depending upon the features enabled for this data service, the
# path may be processed in different ways.

sub BUILD {
    
    my ($self) = @_;
    
    my $ds = $self->{ds};
}


sub is_dataservice_object {
    
    die "must be an object of class Web::DataService"
	unless ref $_[0] && $_[0]->isa('Web::DataService');
}


sub _init_value {
    
    my ($self, $attr) = @_;
    
    if ( my $special = $self->special_value($attr) )
    {
	return $special;
    }
    
    elsif ( my $default = $self->{ds}->node_attr("default_$attr") )
    {
	return $default;
    }
    
    else
    {
	return;
    }
}


# _match_node ( )
# 
# This routine will be called whenever the 'path' attribute of this request is
# set.  It determines the closest matching 'node_path' and sets some other
# attributes.

sub _match_node {
    
    my ($self) = @_;
    
    local($Carp::CarpLevel) = 1;	# We shouldn't have to do this, but
                                        # Moo and Carp don't play well together.
    
    my $ds = $self->{ds};
    my $raw_path = $self->{path};
    my $suffix_is_missing;
    
    # We start with the raw path and trim it in various ways to find the
    # closest matching data service node.
    
    my $node_path = $raw_path;
    
    # If the raw path exactly matches any node, we just use that.  Otherwise,
    # apply any applicable path transformations.
    
    if ( exists $ds->{node_attrs}{$raw_path} )
    {
	$self->{is_node_path} = 1;
    }
    
    else
    {
	# If the feature 'format_suffix' is enabled and the specified path has
	# a suffix, split it off.
	
	if ( $ds->has_feature('format_suffix') )
	{
	    if ( $node_path =~ qr{ ^ (.+) [.] (.+) }xs )
	    {
		$node_path = $1;
		$self->{output_format} = $2;
	    }
	    
	    else
	    {
		$suffix_is_missing = 1;
	    }
	}
	
	# If the feature 'doc_paths' is enabled and the specified path ends in
	# '_doc', remove that string and set the 'doc_path' attribute for this
	# request.  Under this feature, the path "abc/def_doc" indicates a
	# request for doumentation about the path "abc/def".
	
	if ( $ds->has_feature('doc_paths') )
	{
	    if ( $node_path eq '' )
	    {
		$self->{is_doc_request} = 1;
	    }
	    
	    elsif ( ref $ds->{doc_path_regex} eq 'Regexp' && $node_path =~ $ds->{doc_path_regex} )
	    {
		$node_path = $1;
		$self->{is_doc_request} = 1;
	    }
	    
	    elsif ( $ds->{doc_index} && $node_path eq $ds->{doc_index} )
	    {
		$node_path = '';
		$self->{is_doc_request} = 1;
	    }
	    
	    elsif ( $suffix_is_missing )
	    {
		$self->{is_doc_request} = 1;
	    }
	}
	
	# We then lop off components as necessary until we get to a node that has
	# attributes or until we reach the empty string.  We set the 'is_node_path'
	# flag to 0 (unless it has already been set) to indicate that the request
	# path does not fully match a defined node.
	
	while ( $node_path ne '' && ! exists $ds->{node_attrs}{$node_path} )
	{
	    $self->{is_node_path} //= 0;
	    
	    if ( $node_path =~ qr{ ^ (.*) / (.*) }xs )
	    {
		$node_path = $1;
	    }
	    
	    else
	    {
		$node_path = '';
	    }
	}
    }
    
    # An empty path should always produce documentation.  In fact, it should
    # produce a "main documentation page" for this data service.  The data
    # service author should make sure that this is so.
    
    if ( $node_path eq '' )
    {
	$self->{is_doc_request} = 1;
    }
    
    # If the selected node is disabled, set the 'is_invalid_request' attribute.
    
    elsif ( $ds->node_attr($node_path, 'disabled') )
    {
	$self->{is_invalid_request} = 1;
    }
    
    # If 'is_node_path' has not yet been set, then we assume it should be 1.
    
    $self->{is_node_path} //= 1;
    
    # We save all of the characters removed from the raw path as $rest_path,
    # so that (for example) we can send a requested file.
    
    $self->{rest_path} = substr($raw_path, length($node_path));
    
    # If we got an empty path, turn it into the root node path '/'.
    
    $self->{node_path} = $node_path eq '' ? '/' : $node_path;
    
    # If the node that we got has either the 'file_path' or 'file_dir'
    # attribute, then mark this request as 'is_file_path'.  If it has
    # 'file_path', then it is invalid unless $rest_path is empty.  If it has
    # 'file_dir', then it is invalid unless $rest_path is NOT empty.
    
    if ( $ds->node_attr($self->{node_path}, 'file_dir') )
    {
	$self->{is_file_path} = 1;
	$self->{is_invalid_request} = 1 unless defined $self->{rest_path} &&
	    $self->{rest_path} ne '';
    }
    
    elsif ( $ds->node_attr($self->{node_path}, 'file_path' ) )
    {
	$self->{is_file_path} = 1;
	$self->{is_invalid_request} = 1 if defined $self->{rest_path} &&
	    $self->{rest_path} ne '';
    }
}


# execute ( )
# 
# Execute this request, and return the result.

sub execute {
    
    return $_[0]->{ds}->execute_request($_[0]->{outer});
}


# configure ( )
# 
# Configure this request for execution.

sub configure {

    return $_[0]->{ds}->configure_request($_[0]->{outer});
}


# Common methods needed for both execution and documentation

# request_url
# 
# Return the raw (unparsed) request URL

sub request_url {
    
    return $_[0]->{ds}->{foundation_plugin}->get_request_url($_[0]->{outer});
}


# base_url
# 
# Return the base component of the URL for this request, of the form "http://some.host/".

sub base_url {
    
    return $_[0]->{ds}->{foundation_plugin}->get_base_url($_[0]->{outer});
}


# root_url ( )
# 
# Return the base url plus the path prefix.

sub root_url {
    
    return $_[0]->{ds}->{foundation_plugin}->get_base_url($_[0]) . $_[0]->{ds}{path_prefix};
}


# path_prefix ( )
# 
# Return the path prefix for this request.

sub path_prefix {
    
    return $_[0]->{ds}{path_prefix};
}


# data_info ( )
# 
# Return a hash of information about the request.

sub data_info {
    
    my ($self) = @_;
    
    # We start with the information provided by the data service, and add some
    # info specific to this request.
    
    my $ds = $self->{ds};
    my $info = $ds->data_info;
    
    my $node_path = $self->node_path;
    my $base_url = $self->base_url;
    
    my $doc_url = $ds->generate_url({ type => 'relative', documentation => $node_path });
    my $data_url = $self->request_url;
    $data_url =~ s{^/}{};
    
    $info->{documentation_url} = $base_url . $doc_url;
    $info->{data_url} = $base_url . $data_url;
    
    return $info;
}


sub data_info_keys {

    return $_[0]->{ds}->data_info_keys;
}


# special_value ( param )
# 
# Return the value of the specified special param, if it is enabled, and if
# it was specified.  Return undefined otherwise.

sub special_value {

    my ($self, $param) = @_;
    
    my $ds = $self->{ds};
    
    my $param_name = $ds->special_param($param) || return;
    
    # If we have already passed the params through HTTP::Validate, return the
    # cleaned value.
    
    if ( ref $self->{valid} )
    {
	my $value = $self->{valid}->value($param_name);
	return @$value if ref $value eq 'ARRAY';
	return $value if defined $value;
	return; # otherwise
    }
    
    # Otherwise, return the raw value if it exists and undefined otherwise.
    
    return $self->{raw_params}{$param_name};
}


# special_exists ( param )
# 
# Return true if the given special parameter was specified in the request,
# regardless of its value.

sub special_exists {

    my ($self, $param) = @_;
    
    my $ds = $self->{ds};
    my $param_name = $ds->special_param($param) || return;
    
    return exists $self->{raw_params}{$param_name};
}


sub set_scratch {
    
    my ($self, $key, $value) = @_;
    
    return $self->{ds}->set_scratch($key, $value);
}


sub get_scratch {
    
    my ($self, $key) = @_;
    
    return $self->{ds}->get_scratch($key);
}


sub add_warning {

    my ($self, $warn_msg) = @_;
    
    $self->{warnings} = [] unless ref $self->{warnings} eq 'ARRAY';
    push @{$self->{warnings}}, $warn_msg;
}


sub warnings {

    my ($self) = @_;
    
    return @{$self->{warnings}} if ref $self->{warnings} eq 'ARRAY';
}


sub error_result {
    
    my ($self, $error) = @_;
    
    return $self->{ds}->error_result($error, $self);
}

=head1 NAME

Web::DataService::Request - interface for handling a single request

=head1 SYNOPSIS

The way that you handle a result using Web::DataService is as follows:

    my $request = $ds->new_request(undef, $path);
    $request->execute;

The C<new_request> method creates a new C<Web::DataService::Request> object,
whose attributes are set according to the given path.

The C<execute> method then processes the request as indicated by these
attributes; if you have specified C<class> and C<method>, then the appropriate
method is called.

=head1 METHODS

=head3 new ( ds, outer, path )

You will probably not call this method directly; instead, call the
C<new_request> method of L<Web::DataService>, which calls it internally after
carrying out other processing such as selecting among sub-services.

If you do call it directly, the parameter C<ds> must be an instance of
C<Web::DataService>. The parameter C<outer> should be a reference to the
request object generated by the underlying Web Application Framework
(i.e. L<Dancer>). The parameter C<path> must be the path corresponding to the
selected operation.

Returns a new instance of C<Web::DataService::Request>, whose attributes are
set from the given path.

=head3 execute ( )

Executes this request, and sends a result message using the foundation
framework.

=head3 clean_param ( param )

Returns the cleaned value of the specified parameter, or undefined if the
parameter was not specified.  If more than one parameter value was given, the
result will be an array ref.

=head3 clean_param_list ( param )

Returns a list of one or more values of the specified parameter, or undefined
if the parameter was not specified.

=head3 result_limit ( )

If the attribute C<limit_param> was specified for the data service, and if it
was specified with this request, then the given value is returned.  If the
parameter was given a value of C<all>, then this method returns undefined.

If the parameter was not specified at all, or if C<limit_param> was never
specified, then the C<default_limit> attribute of the data service is
returned.

=head3 result_offset ( will_handle )

If the attribute C<offset_param> was specified for the data sevice, and if it
was specified with this request with a non-zero value, the given value is
returned.  Otherwise, the method returns 0.

If C<will_handle> is true, then no further processing is done on the result.
If C<will_handle> is false, or if C<result_offset> is never called for this
request, then (if the request includes the parameter whose name is specified
by C<offset_param>, with a numeric value) that number of result records will
be dropped before any output is generated.

If the attribute C<offset_param> is not specified for this data service, or if
that parameter is not included in the request, then no dropping of records
will occur.

=head3 sql_limit_clause ( will_handle )

Returns an SQL C<LIMIT> clause which will reflect the values of C<limit_param>
and C<offset_param>, if one or both were specified for this data service and
if the corresponding parameter(s) were included in this request.  Otherwise,
returns the empty string.

The argument C<will_handle> is treated exactly as with L</result_offset> above.

=head3 sql_count_clause ( )

If the attribute C<count_param> was defined for this data service, and if the
corresponding parameter was included in this request, returns the string
"SQL_CALC_FOUND_ROWS".  Otherwise, returns the empty string.

=head3 sql_count_rows ( )

If the attribute C<count_param> was defined for this data service, and if the
corresponding parameter was included in this request, executes the SQL
statement "SELECT FOUND_ROWS()" and stores the result for later use in
generating a response header.  Otherwise, it does nothing.

=head3 set_result_count ( count )

This method can be used as an alternative to L</sql_count_rows>.  In your own
operation methods, you can check for the size of the result set in whatever
way is appropriate for your backend and call this method with the resulting
number.  If you wish, you can do this only if the parameter C<count_param> was
included with this request.

=head3 add_warning ( message )

Add the specified warning message to this request.  The warnings will be
automatically included in the result, in a manner appropriate for the selected
output format.

=head3 warnings ( )

Return a list of the warning messages (if any) that have been added to this
request. 

=head3 output_format ( )

Return the output format that has been selected for this request.

=head3 get_request_url ( )

Return the raw (unparsed) URL for this request.

=head3 get_base_url ( )

Return the base of the URL for this request.  This will generally be of the
form C<http://domain.name/>.

=head3 get_request_path ( )

Return the remainder of the URL path after the base (but without the format
suffix, if any).

=head3 set_content_type ( content_type )

Set the response content type.  You will probably not need to call this
method, since the content type is generally set automatically based on the
selected output format.

=head1 AUTHOR

mmcclenn "at" cpan.org

=head1 BUGS

Please report any bugs or feature requests to C<bug-web-dataservice at rt.cpan.org>, or through
the web interface at L<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Web-DataService>.  I will be notified, and then you'll
automatically be notified of progress on your bug as I make changes.

=head1 COPYRIGHT & LICENSE

Copyright 2014 Michael McClennen, all rights reserved.

This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

=cut

1;
